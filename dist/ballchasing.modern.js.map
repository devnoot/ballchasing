{"version":3,"file":"ballchasing.modern.js","sources":["../node_modules/form-data/lib/browser.js","../src/BallChasingAPI.ts"],"sourcesContent":["/* eslint-env browser */\nmodule.exports = typeof self == 'object' ? self.FormData : window.FormData;\n","import fetch, {Response} from \"node-fetch\";\nimport * as fs from \"fs\";\nimport * as FormData from \"form-data\";\nimport {MatchResult, Playlist, Rank, SortBy, SortDir, Visibility} from \"./types\";\n\nexport interface ListReplaysArgs {\n    title?: string\n    playerName?: string\n    playerId?: string\n    playlist?: Playlist\n    season?: string\n    matchResult?: MatchResult\n    minRank?: Rank\n    maxRank?: Rank\n    pro?: boolean\n    uploader?: string\n    group?: string\n    // This is actually an enum from GET /maps\n    map?: string\n    // RFC3339 Format\n    createdBefore?: string\n    createdAfter?: string\n    replayDateAfter?: string\n    replayDateBefore?: string\n    count?: number\n    sortBy?: SortBy\n    sortDir?: SortDir\n}\n\nexport interface DeleteReplayArgs {\n    id: string\n}\n\nexport interface PatchReplayArgs {\n    id: string\n    // the patch data, for example, {\"title\":\"patched title\"}\n    patch: {\n        [key: string]: string\n    }\n}\n\nexport interface DownloadReplayArgs {\n    id: string\n}\n\nexport interface GetReplayArgs {\n    id: string\n}\n\nexport interface CreateGroupArgs {\n    name: string\n    parent?: string\n    playerIdentification: \"by-id\" | \"by-name\"\n    teamIdentification: \"by-distinct-players\" | \"by-player-clusters\"\n}\n\nexport interface ListGroupsArgs {\n    name?: string\n    creator?: string\n    group?: string\n    createdBefore?: string\n    createdAfter?: string\n    count?: number\n    sortBy?: SortBy\n    sortDir?: SortDir\n}\n\nexport interface DeleteGroupArgs {\n    id: string\n}\n\nexport interface PatchGroupArgs {\n    id: string\n    // the patch data, for example, {\"title\":\"patched title\"}\n    patch: {\n        [key: string]: string\n    }\n}\n\nexport interface GetGroupArgs {\n    id: string\n}\n\nexport class BallChasingAPI {\n\n    private readonly _apiKey;\n    private readonly _baseURL;\n\n    constructor(apiKey: string) {\n        this._apiKey = apiKey;\n        this._baseURL = new URL(\"https://ballchasing.com/api\")\n    }\n\n    /**\n     * Create the authorization headers needed to call the\n     * ballchasing API.\n     * @private\n     */\n    private authHeaders() {\n        return {\"Authorization\": this._apiKey};\n    }\n\n    /**\n     * Make a request to the ballchasing API. This method will\n     * check the response for errors.\n     * @param url\n     * @param fetchArgs Any extra fetch args\n     * @param headers Any extra headers\n     * @private\n     */\n    private async request(url: URL, fetchArgs?: RequestInit, headers?: HeadersInit) {\n        try {\n            const args: RequestInit = {\n                headers: {\n                    ...this.authHeaders(),\n                    ...headers\n                },\n                ...fetchArgs\n            }\n\n            // @ts-ignore\n            const res = await fetch(url, args);\n            const json = await res.json();\n\n            return {response: res, data: json};\n\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    /**\n     * Checks if\n     * 1) Your API key is correct\n     * 2) If ballchasing API is reachable\n     */\n    async ping() {\n        try {\n            return await this.request(this._baseURL);\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Upload a replay\n     *\n     * @param filepath\n     * @param groupId\n     * @param visibility\n     */\n    async uploadReplay(filepath: string, groupId?: string, visibility?: Visibility) {\n        try {\n            const endpoint = new URL(\"/api/v2/upload\", this._baseURL);\n\n            if (visibility) {\n                endpoint.searchParams.set(\"visibility\", visibility);\n            }\n\n            if (groupId) {\n                endpoint.searchParams.set(\"group\", groupId);\n            }\n\n            const stats = fs.statSync(filepath);\n            const stream = fs.createReadStream(filepath);\n\n            const formData = new FormData();\n            formData.append(\"file\", stream, {knownLength: stats.size});\n\n            const args = {method: \"POST\", body: formData};\n\n            // @ts-ignore\n            return await this.request(endpoint, args);\n\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    async getMaps() {\n        try {\n            const endpoint = new URL(\"/api/maps\", this._baseURL);\n            return await this.request(endpoint);\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    async listReplays(args: ListReplaysArgs) {\n        try {\n\n            const endpoint = new URL(\"/api/replays\", this._baseURL);\n\n            if (args.title) {\n                endpoint.searchParams.set(\"title\", args.title);\n            }\n\n            if (args.playerName) {\n                endpoint.searchParams.set(\"player-name\", args.playerName);\n            }\n\n            if (args.playerId) {\n                endpoint.searchParams.set(\"player-id\", args.playerId);\n            }\n\n            if (args.playlist) {\n                endpoint.searchParams.set(\"playlist\", args.playlist);\n            }\n\n            if (args.season) {\n                endpoint.searchParams.set(\"season\", args.season);\n            }\n\n            if (args.matchResult) {\n                endpoint.searchParams.set(\"match-result\", args.matchResult);\n            }\n\n            if (args.minRank) {\n                endpoint.searchParams.set(\"min-rank\", args.minRank);\n            }\n\n            if (args.maxRank) {\n                endpoint.searchParams.set(\"max-rank\", args.maxRank);\n            }\n\n            if (args.pro) {\n                endpoint.searchParams.set(\"pro\", \"true\");\n            }\n\n            if (args.uploader) {\n                endpoint.searchParams.set(\"uploader\", args.uploader);\n            }\n\n            if (args.group) {\n                endpoint.searchParams.set(\"group\", args.group);\n            }\n\n            if (args.map) {\n                endpoint.searchParams.set(\"map\", args.map);\n            }\n\n            if (args.createdBefore) {\n                endpoint.searchParams.set(\"created-before\", args.createdBefore);\n            }\n\n            if (args.createdAfter) {\n                endpoint.searchParams.set(\"created-after\", args.createdAfter);\n            }\n\n            if (args.replayDateBefore) {\n                endpoint.searchParams.set(\"replay-date-before\", args.replayDateBefore);\n            }\n\n            if (args.replayDateAfter) {\n                endpoint.searchParams.set(\"replay-date-after\", args.replayDateAfter);\n            }\n\n            if (args.count) {\n                endpoint.searchParams.set(\"count\", args.count.toString());\n            }\n\n            if (args.sortDir) {\n                endpoint.searchParams.set(\"sort-dir\", args.sortDir);\n            }\n\n            if (args.sortBy) {\n                endpoint.searchParams.set(\"sort-by\", args.sortBy);\n            }\n\n            return await this.request(endpoint);\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    async getReplay(args: GetReplayArgs) {\n        try {\n            const endpoint = new URL(`/api/replays/${args.id}`, this._baseURL);\n            return await this.request(endpoint);\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async patchReplay({id, patch}: PatchReplayArgs) {\n        try {\n            const endpoint = new URL(`/api/replays/${id}`, this._baseURL);\n            return await this.request(\n                endpoint,\n                {method: \"PATCH\", body: JSON.stringify({...patch})},\n                {\"Content-Type\": \"application/json\"}\n            );\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async deleteReplay(args: DeleteReplayArgs) {\n        try {\n            const endpoint = new URL(`/api/replays/${args.id}`, this._baseURL);\n            return await this.request(\n                endpoint,\n                {method: \"DELETE\"}\n            );\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async downloadReplay(args: DownloadReplayArgs) {\n        try {\n            const endpoint = new URL(`/api/replays/${args.id}/file`, this._baseURL);\n            return await fetch(endpoint, {\n                headers: {\n                    ...this.authHeaders()\n                }\n            });\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async createGroup(args: CreateGroupArgs) {\n        try {\n            const endpoint = new URL(\"/api/groups\", this._baseURL);\n            return await this.request(\n                endpoint,\n                {method: \"POST\", body: JSON.stringify({...args})},\n                {\"Content-Type\": \"application/json\"}\n            );\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async listGroups(args: ListGroupsArgs = {}) {\n        try {\n            const endpoint = new URL(\"/api/groups\", this._baseURL);\n\n            if (args.name) {\n                endpoint.searchParams.set(\"name\", args.name);\n            }\n\n            if (args.count) {\n                endpoint.searchParams.set(\"count\", args.count.toString());\n            }\n\n            if (args.creator) {\n                endpoint.searchParams.set(\"creator\", args.creator);\n            }\n\n            if (args.createdBefore) {\n                endpoint.searchParams.set(\"created-before\", args.createdBefore);\n            }\n\n            if (args.createdAfter) {\n                endpoint.searchParams.set(\"created-after\", args.createdAfter);\n            }\n\n            if (args.sortBy) {\n                endpoint.searchParams.set(\"sort-by\", args.sortBy);\n            }\n\n            if (args.sortDir) {\n                endpoint.searchParams.set(\"sort-dir\", args.sortDir);\n            }\n\n            if (args.group) {\n                endpoint.searchParams.set(\"group\", args.group);\n            }\n\n            return await this.request(endpoint);\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async getGroup(args: GetGroupArgs) {\n        try {\n            const endpoint = new URL(`/api/groups/${args.id}`, this._baseURL);\n            return await this.request(endpoint);\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async deleteGroup(args: DeleteGroupArgs) {\n        try {\n            const endpoint = new URL(`/api/groups/${args.id}`, this._baseURL);\n            return await this.request(endpoint, {method: \"DELETE\"});\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    async patchGroup({id, patch}: PatchGroupArgs) {\n        try {\n            const endpoint = new URL(`/api/groups/${id}`, this._baseURL);\n            return await this.request(endpoint, {\n                method: \"PATCH\",\n                body: JSON.stringify({...patch})\n            }, {\"Content-Type\": \"application/json\"});\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n}"],"names":["self","FormData","window","BallChasingAPI","constructor","apiKey","this","_apiKey","_baseURL","URL","authHeaders","Authorization","[object Object]","url","fetchArgs","headers","args","res","fetch","json","response","data","e","Error","request","filepath","groupId","visibility","endpoint","searchParams","set","stats","fs","statSync","stream","createReadStream","formData","append","knownLength","size","method","body","title","playerName","playerId","playlist","season","matchResult","minRank","maxRank","pro","uploader","group","map","createdBefore","createdAfter","replayDateBefore","replayDateAfter","count","toString","sortDir","sortBy","id","patch","JSON","stringify","Content-Type","name","creator"],"mappings":"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"}